Had a lot of trouble with this one. I tried different approaches but they didn't work for the second one. Basically I wanted to capture all the `mul(x,y)` between `do()` and `don't()`. This didn't work and I don't really know why. I did think about adding a `do()` at the start and a `don't()` at the end but this wasn't enough to make it work.

So instead I wrote a small parser. First I filtered to keep only `do()`, `don't()` and `mul(x,y)`. I used regexes as I know regexes, and Rust doesn't have a `scanf`-like in the standard library (to be fair regexes aren't in the standard library either). After extracting only what I needed, I tokenized (three tokens, `Token::Do`, `Token::Dont`, `Token::Mul(i32,i32)`). Then after that it's a simple for loop. To tokenize I implemented `FromStr` for `Token`, again using regexes for the `Mul`. This was kind of slow and I figured that like in Go, maybe creating the regex at each function call takes a lot of time. I searched for how to initialize it only once, used `lazy_static` and now it's not slow anymore (from ~1 second for cargo run to ~0.03 seconds).

After that I wanted to try a more functional approach. It's not a simple reduce like the first star where you simply add all the time, you need to keep track of if you're inside/after a "do" or not. To do that, I use the trick of "the accumulator in reduce also has the current state", which means my accumulator is a tuple containing the current result and if I'm after a `do()` or after a `don't()`.
